// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: products.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const createProduct = `-- name: CreateProduct :exec
INSERT INTO product (id, title, description, price, created_at, updated_at) 
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateProductParams struct {
	ID          string
	Title       string
	Description sql.NullString
	Price       int32
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.ExecContext(ctx, createProduct,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createProductCategory = `-- name: CreateProductCategory :exec
INSERT INTO product_category (id, product_id, category_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateProductCategoryParams struct {
	ID         string
	ProductID  string
	CategoryID string
	CreatedAt  time.Time
	UpdatedAt  time.Time
}

func (q *Queries) CreateProductCategory(ctx context.Context, arg CreateProductCategoryParams) error {
	_, err := q.db.ExecContext(ctx, createProductCategory,
		arg.ID,
		arg.ProductID,
		arg.CategoryID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM product WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const deleteProductCategory = `-- name: DeleteProductCategory :exec
DELETE FROM product_category WHERE product_id = $1 AND category_id = $2
`

type DeleteProductCategoryParams struct {
	ProductID  string
	CategoryID string
}

func (q *Queries) DeleteProductCategory(ctx context.Context, arg DeleteProductCategoryParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductCategory, arg.ProductID, arg.CategoryID)
	return err
}

const findManyProducts = `-- name: FindManyProducts :many
SELECT
p.id, 
p.title, 
p.description, 
p.price, 
p.created_at
FROM product p 
JOIN product_category pc ON pc.product_id = p.id
WHERE 
  (pc.category_id  = ANY($1::TEXT[]) OR $1::TEXT[] IS NULL)
  AND (
    p.title ILIKE '%' || COALESCE($2, $2, '') || '%' 
    OR 
    p.description ILIKE '%' || COALESCE($2, $2, '') || '%'
  )
ORDER BY p.created_at DESC
`

type FindManyProductsParams struct {
	Categories []string
	Search     sql.NullString
}

type FindManyProductsRow struct {
	ID          string
	Title       string
	Description sql.NullString
	Price       int32
	CreatedAt   time.Time
}

func (q *Queries) FindManyProducts(ctx context.Context, arg FindManyProductsParams) ([]FindManyProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, findManyProducts, pq.Array(arg.Categories), arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindManyProductsRow
	for rows.Next() {
		var i FindManyProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesByProductID = `-- name: GetCategoriesByProductID :many
SELECT pc.category_id FROM product_category pc WHERE pc.product_id = $1
`

func (q *Queries) GetCategoriesByProductID(ctx context.Context, productID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCategoriesByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var category_id string
		if err := rows.Scan(&category_id); err != nil {
			return nil, err
		}
		items = append(items, category_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT EXISTS (SELECT 1 FROM category WHERE id = $1) AS category_exists
`

func (q *Queries) GetCategoryByID(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, getCategoryByID, id)
	var category_exists bool
	err := row.Scan(&category_exists)
	return category_exists, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT EXISTS (SELECT 1 FROM product WHERE id = $1) AS product_exists
`

func (q *Queries) GetProductByID(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var product_exists bool
	err := row.Scan(&product_exists)
	return product_exists, err
}

const getProductCategories = `-- name: GetProductCategories :many
SELECT c.id, c.title FROM category c 
JOIN product_category pc ON pc.category_id = c.id 
WHERE pc.product_id = $1
`

type GetProductCategoriesRow struct {
	ID    string
	Title string
}

func (q *Queries) GetProductCategories(ctx context.Context, productID string) ([]GetProductCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductCategories, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductCategoriesRow
	for rows.Next() {
		var i GetProductCategoriesRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE product
SET
title = COALESCE($3, title),
description = COALESCE($4, description),
price = COALESCE($5, price),
updated_at = $2
WHERE id = $1
`

type UpdateProductParams struct {
	ID          string
	UpdatedAt   time.Time
	Title       sql.NullString
	Description sql.NullString
	Price       sql.NullInt32
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.ExecContext(ctx, updateProduct,
		arg.ID,
		arg.UpdatedAt,
		arg.Title,
		arg.Description,
		arg.Price,
	)
	return err
}
